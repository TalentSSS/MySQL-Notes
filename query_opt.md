# 第5章 查询优化

查询在概念上是集合操作，没有时间的概念。

但数据库管理系统具体实现会受到各种真实物理条件的约束。因此查询需要占用一定的时间。

为了减少查询时间，就需要把对集合的瞬时数学操作抽象搁置一边，寻找能够加快查询的方法。所幸的是，还真有一些技术可以实现这个目标

* 为表**创建索引**，能让数据库服务器查找行的速度更快
* 认真考虑**如何编写能够最大程度利用这些索引的查询**，并且使用EXPLAIN语句来检查 MySQL服务器是否真的那样做了
* 选择能够让服务器进行高效处理的**数据类型和表存储格式**

本章将从上述几个方面的内容，介绍如何优化数据库性能、加快查询。

## 5.1 使用索引

用来加速查询的技术有很多，其中最为重要的就是索引。应该首先使用索引来最大程度地改进性能，再考虑其他技术。

### 5.1.1 索引的优点

索引提高效率的方式

* 得知匹配行在什么位置结束，从而跳过其余部分

* 利用定位算法，不用从索引开始位置进行线性扫描，即可直接找到第一个匹配项（例如，二分搜索比扫描要快很多）。以便快速地定位到第一个匹配值，节省搜索时间

只要知道使用索引是加快查询的好方法就可以。

如果表只有一个索引，直接对数据行排序，省掉索引操作，也可以加快搜索速度。但是有可能需要添加多个索引，就无法同时按照不同方式对数据行进行排序。

此外，索引里的行通常都要比表里的数据行更短。修改索引比修改数据行更加容易。

对于不同的MySQL存储引擎，索引的具体实现细节会有所不同。

* MyISAM引擎

    MyISAM表，将数据行保留在数据文件里，**索引值保留在索引文件里**。

* InnoDB引擎

    给定表的数据和索引保存在同一个表空间文件里。

在查询单个表时，使用索引可以不再需要执行全表扫描，从而极大地提高搜索速度。

在执行连接多个表的查询时，索引发挥的作用更大。

在执行单表**全扫描查询**时，你必须不断地检查行数，以确保它就是表的行数。在多表查询里， 需要检查的行数就是所有表行数乘积，有可能是一个天文数字。   

索引有以下几个发挥作用的场景

* 用于加快对**WHERE子句**里匹配的行进行搜索的速度，或者用于加快对与另一个连接表里的行匹配的行进行搜索的速度。
* 对于使用**MIN()或MAX()函数的查询**，MySQL可以在不用逐行检查的情况下，快速找到索引列里的最小值或最大值。
* 对于**ORDER BY和GROUP BY子句**，使用索引来高效地完成分类和分组操作。
* 有时，MySQL也会通过索引来读取查询所请求的信息。

### 5.1.2 索引的代价

一般来讲，MySQL知道如何通过索引来更快速地处理查询。这意味着，在大部分情况下，不为表创建索引就是在自残。

但索引也有缺点吗？在时间和空间上都有成本。

因此需要对缺点有所了解。

首先，索引可以加快检索速度，但**维护索引需要时间成本**，这降低了索引列插入、删除和更新值（大部分与写入相关的操作）的速度。 

其次，索引也会**占用磁盘空间**，多个索引会占据更大的空间。与没有索引相比，使用索引会让你很快便达到表的大小极限。

* 对于MyISAM表，大量地对它进行索引，有可能导致索引文件比数据文件更快地到达其最大大小。

* 存储在InnoDB系统表空间里的所有InnoDB表，都共享同一个存储空间池，添加索引会使表空间里用于存储的空间减少得更快。不过，与MyISAM表所用的文件不同，**InnoDB系统表空间不会受到操作系统文件大小的限制**，因为可以配置它使用多个文件来扩展空间。

**如果不需要某个特定的索引来加快查询速度，那么就不要创建它**。

### 5.1.3 挑选索引

* 为用于**搜索、排序或分组、连接**的列创建索引，而对于用作输出显示的列则不用创建索引

* 认真考虑数据**列基数**，即在某列数据中，相异数据的总数

* 索引**短小值**，应尽量选用较小的数据类型。

* 索引**字符串值的前缀**

* 利用**最左前缀**。索引中最左边的任意数据列集合都可用于匹配各个行，这样的集合即为"最左前缀"。 

* 不要建立过多的索引。请维护好那些真正需要的索引。

* 让参与比较的索引类型保持匹配。在创建索引时，大部分存储引擎都会选择它们要使用的索引实现。InnoDB总会使用B树索引。MylSAM也会使用B树索引，但对于空间类型则会改用R树索引，MEMORY存储引擎默认会使用散列索引，但它也支持B树索引，并允许你在这两者之间进行选择。

    不同的索引支持各自适合的比较操作，在选择索引类型时，请考虑计划在索引列上执行的是什么类型的比较操作。

* 利用**慢查询日志**找出那些性能低劣的查询。

## 5.2 MySQL查询优化程序

当你调用语句时，MySQL会先对它进行分析，判断出可以使用哪些优化操作来加快处理速度。

MySQL的查询优化程序会充分利用索引，但它同时也会通过一些其他手段优化程序，例如MySQL会去先检查WHERE子句，如果发现没有符合查询条件的行，就不会去搜索表。

通过执行EXPLAIN语句，可以告知MySQL, 把SELECT如何执行的（并非实际执行）相关信息显示出来。（自MySQL 5.6.3开始，也可以将EXPLAIN 与DELETE、INSERT、REPLACE和UPDATE语句一起使用。）   

EXPLAIN获得的信息包括

* 将用于扫描各个表的索引
* 将要用到的连接类型
* 以及每个表都必须要检查的行数的粗略估计。

在某些情形下，如果某个查询的FROM子句里包含了子查询，那么EXPLAIN会先执行这个查询的一部分：在对主SELECT语句进行分析之前，EXPLAIN必须先执行子查询，才能知道它们返回的具体内容。

### 5.2.1 查询优化程序的工作原理

查询优化程序有几个目标，但是主要目标是：**尽可能使用索引**，并且**使用最严格的索引**来消除对行数量随时可能快速增加的顾虑

优化程序对索引的充分利用的方法：

* 分析表。生成关于键值分布情况的统计数据，它们可以帮助优化程序更准确地评估索引效率，可以根据表的改动频率定期做分析。

* 使用EXPLAIN验证优化程序的操作

* 在必要时给予优化程序提示或改写它。在连接操作的表里，可以在表名的后面加上FORCE INDEX、USE INDEX或IGNORE INDEX，告知服务器期望使用哪些索引；也可以通过STRAIGHT_JOIN强制要求优化程序**按特定的顺序使用各个表**。

    ```mysql
SELECT STRAIGHT_JOIN ... FROM t1 INNER JOIN t2 INNER JOIN t3 ...; 
    SELECT ... FROM tl STRAIGHT_JOIN t2 STRAIGHT_JOIN t3 ...;
    ```
    
    一定要对比试试有和没有STRAIGHT_JOIN的情况，MySQL可能有更好的理由。可以使用EXPLAIN语句检查一下具体的执行计划，看看MySQL是如何处理每一条语句的

* 比较拥有相同数据类型的列。在对带有索引的列进行比较时，数据类型相同比数据类型不同的情况查询性能高很多

* 避免过多使用自动类型转换

    - 查询的比较需要进行类型转转换
    - 涉及类型转换的比较有可能会阻止使用索引

* 让索引列在比较表达式中单独出现。如果你在函数调用中使用了列，或者将列当作是复杂算术表达式中的一部分，那么MySQL将不会使用该索引，因为它必须计算每一个行的表达式值。

    下面两条WHERE子句说明了整个工作过程。它们在算术上是等效的，但其优化目的却大不一样

    ```mysql
    WHERE mycol * 2 < 4
    WHERE mycol < 4 / 2
    ```

    这里的第二行要好于第一行。

    让我们来看另外一个示例。假设，有一个DATE类型索引列date_col。执行如下所示的查询，那么索引将不会被用到：

    ```mysql
    SELECT * FROM mytbl WHERE YEAR(date_col) < 1990;
    ```

    可以使用文字型日期来解决这个问题，让优化程序就会使用date_col的索引来查找相匹配的列值

    ```mysql
    WHERE date_col < '1990-01-01'
    ```

    但是，如果只是想要把那些从今天算起一定天数以内的行找出来。有多种方式可以表达这种类型的比较操作，但效果不尽相同。这里列出了其中的3种：

    ```mysql
    WHERE TO_DAYS(date_col) - TO_DAYS (CURDATE ()) < cutoff
    WHERE TO_DAYS(date_col) < cutoff + TO_DAYS (CURDATE ())
    WHERE date_col < DATE_ADD(CURDATE(), INTERVAL cutoff DAY)
    ```

* 不要在LIKE模式的开始位置使用通配符

    对于这样的查询语句

    ```mysql
    WHERE last_name LIKE 'Mac%'
    ```

    优化程序会查看这个模式的文字初始部分，并使用索引来找到匹配的行，跟下面编写的表达式一样，这种形式的表达式允许使用last_name的索引

    ```mysql
    WHERE last_name >='Mac' AND last_name <'Mad'
    ```

    这种优化方式不能用于使用REGEXP运算符的模式匹配。

* 利用优化程序的长处。MySQL支持连接和子查询，但子查询支持是最近才开始有的功能。因此，优化程序在许多场合对连接的优化效果，要比对子查询的优化效果更好一些。

* 测试查询的各种替代形式，并多次运行它们

### 5.2.2 使用EXPLAIN检查优化程序的操作

EXPLAIN语句提供的信息，有助于我们了解优化程序为处理各种语句而生成的执行计划。

EXPLAIN语句的两种用途。   

* 确定以不同方式编写出来的查询命令，是否会影响索引的使用。   

* 研究给表增加索引，对优化程序生成高效执行计划的能力会产生什么影响。

使用5.2.1节讨论过的例子，来对EXPLAIN有直观印象

```mysql
WHERE TO_DAYS(date_col) - TO_DAYS(CURDATE()) < cutoff
WHERE TO_DAYS(date_col) < cutoff + TO_DAYS(CURDATE())
WHERE date_col < DATE_ADD(CURDATE(), INTERVAL cutoff DAY)
```

使用sampdb里的member表，首先对expiration列添加索引

```mysql
ALTER TABLE member ADD INDEX(expiration);
```

再用EXPLAIN检查各种查询形式

  ```mysql
mysql> EXPLAIN SELECT * FROM member
	-> WHERE TO_DAYS(expiration) - TO_DAYS(CURDATE()) < 30;
mysql> EXPLAIN SELECT * FROM member
	-> WHERE TO_DAYS(expiration) < 30 + TO_DAYS(CURDATE());
mysql> EXPLAIN SELECT * FROM member
	-> WHERE expiration < DATE_ADD(CURDATE(), INTERVAL 30 DAY);
  ```

输出结果

* type的值表明，优化程序可以使用索引来搜索特定范围内的值（即那些小于表达式的右半部分所给出的日期的值）。

* possible_keys和key的值表明，将表中的哪些索引视为候选索引，实际上也会使用这些索引。

* row的值表明，优化程序估计完成此次查询需要检查的行数。

EXPLAIN的第二个用途是，验证增加索引能否有助于优化程序更有效地执行某条语句。

例如，我起初只使用了两个无索引的表。它们各有1000个行，其中行包含的值为1-1000。

下面是用于检验那些行的查询命令，它会把两个表里对应值相等的那些行找出来

```mysql
mysql> SELECT t1.i1, t2.i2 FROM t1 INNER JOIN t2
	-> WHERE t1.i1 =t2.i2;
```

两个表都没索引的时候，EXPLAIN该查询语句

```mysql
mysql> EXPLAIN SELECT t1.i1, t2.i2 FROM t1 INNER JOIN t2
	-> WHERE t1.i1 =t2.i2;
```

增加索引

```mysql
mysql> ALTER TABLE t2 ADD INDEX (i2);
mysql> EXPLAIN SELECT t1.i1, t2.i2 FROM t1 INNER JOIN t2
	-> WHERE t1.i1 = t2.i2;
```

为了帮助优化程序获得更有价值的估算值，还可以运行ANALYSE TABLE命令。这将使服务器生成关于键值分布情况的统计数据。分析这些表，并再次运行EXPLAIN, 便可得到更准确的rows估算值。

## 5.3 选择利于高效查询的数据类型

对数据类型的选择，会在许多方面影响查询性能。

一些与数据类型选择有关的建议

* 多用数字运算，少用字符串运算
* 当较小类型够用时，就不用较大类型
* 把数据列声明成NOT NULL
* 考虑使用ENUM列
* 使用PROCEDURE ANALYSE ()，对适用于表里各个列的优化数据类型给出了建议
* 整理表碎片。定期使用OPTIMIZE TABLE，可以消除或减少碎片化的MyISAM或InnoDB表里的空间浪费，有助于防止性能降低。
* 把数据压缩到BLOB或TEXT列。 
* 使用合成索引。合成索引列有时很有用。一种做法是，先根据表里的其他列计算出一个散列值，把它存储到一个单独的列里。然后通过搜索散列值来检索行。不过，这个技术只适用于**精确匹配型查询**。
* 避免检索很大的BLOB或TEXT值，除非迫不得已。
* 把BLOB或TEXT列剥离出来形成一个单独的表。

## 5.4 选择利于高效查询的表存储格式

有些存储引擎实现了多种存储格式，其中每一种都有其自己的性能特性。

如果所有列的长度固定，那么MylSAM存储引擎默认会使用固定长度的行，但如果任何一列的长度都是可变的，那么它会使用可变长度的行。

* 对于变长行，由于各行的大小不一，执行过多的删除或更新操作时，会产生更多的碎片。要定期OPTIMIZE TABLE。

* 当表崩溃时，具有固定长度行的表更易于重建。

由于MEMORY表使用的是固定长度的行，而且其中的CHAR和VARCHAR列都被隐式地当作CHAR来对待，因此不管你选择哪一个都没关系。

InnoDB并不会区别对待固定长度列和可变长度列（所有行都使用一个指向列值的头指针）， 所以使用CHAR列在本质上不会比使用VARCHAR列更简单。

当创建InnoDB表时，请选择其特性与存储在表中的数据完美匹配的行存储格式。

* 默认情况下，InnoDB会使用COMPACT行格式。这种选择适合于大部分的情形。

* 对于包含重复数据的表，使用COMPRESSED行格式，能带来更多的好处。这种表占用的空间更少，而省下来读取数据的时间，远远超过解压它所需的CPU时间。压缩格式对于存储随机值或已压缩过的值的表没有用。适合用于网络传输差的情况

* 对于带有长BLOB或TEXT值的表，DYNAMIC行格式最有效。

想要为新的lnnoDB表指定行格式，可以使用ROW_FORMAT表选项。例如：

```mysql
CREATE TABLE t1 (...) ENGINE=InnoDB ROW_FORMAT=COMPRESSED;
```

想要检查已有表的行存储格式，可以使用SHOW TABLE STATUS。

想要更改表的格式，可以使用ALTER TABLE

```mysql
ALTER TABLE t1 ROW_FORMAT=DYNAMIC;
```

行格式COMPRESSED和DYNAMIC需要Barracuda文件格式，需要正确设置系统变量

## 5.5 高效加载数据

与查询语句优化相比，将数据加载到数据库则较为简单。但还是有许多策略可用于提高数据加载的效率。

这些基本原则如下

* 把数据**从缓存刷新到磁盘的次数越少，那么数据加载的速度就越快**；批量记载的效率比单行加载的效率更高。

* 表的**索引越少，加载速度越快**。

* 与**长SQL语句相比，短语句在服务器上的解析操作会更少**，数据加载速度更快，它们可以更加快速地通过网络从客户端发送到服务器。

几个有关如何快速加载数据的实用结论

* LOAD DATA（包括各种形式）的效率比INSERT的高，因为它是**批量加载**行。

* LOAD DATA在不带LOCAL的情况下效率会更高。

* 如果必须使用INSERT, 那么请尝试使用那种允许在**单条语句里插入多个行的格式**。

    这里强调的是：与使用一组等效的插入单行的 INSERT语句相比，使用单条可插入多个行的INSERT语句，总体上花费的时间会更短，而且服务器在处理多行插入语句时，需要的索引刷新次数会更少。

* 如果使用mysqldump程序来生成数据库备份文件，那么它会默认生成可插入多行的INSERT语句：启用--opt (优化）选项，此选项会打开--extended-insert选项，产生可插入多行的 INSERT语句；此外，还会启用一些其他选项，使得在重新加载转储文件时，能更高效地处理转储文件。

* 要避免在mysqldump程序里使用--complete-insert选项。否则，最终生成的INSERT语句将是针对单行的，与可插入多行的语句相比，它们更长、需要执行更多的解析处理。

* 如果必须使用多条INSERT语句，尽可能把它们分组，以减少刷新索引的次数

    * 对于支持事务的存储引擎，可以在单个事务里执行INSERT语句，不要以自动提交的方式来执行：

        ```mysql
        START TRANSACTION;
        INSERT INTO tbl_name ... ;
        INSERT INTO tbl_name ... ;
        INSERT INTO tbl_name ... ;
        COMMIT;
        ```

    * 对不支持事务的存储引擎，可以先占用对表的写入锁，然后在表被锁定时，执行INSERT语句：

        ```mysql
        LOCK TABLES tbl_name WRITE;
        INSERT INTO tbl_name ... ;
        INSERT INTO tbl_name ... ;
        INSERT INTO tbl_name ... ;
        UNLOCK TABLES;
        ```

        这样，只有在所有语句都执行完以后，MySQL才会刷新一次索引；而不是在每个INSERT语句执行完之后都刷新一次。

    * 对MyISAM表，减少索引刷新次数的另一种策略是，使用DELAY_KEY_WRITE表选项。使用这个选项，行便可以像往常一样被立刻写入数据文件，但键缓存只有在必要时才会刷新一次，而不是每次插入之后都会立刻刷新。

* 使用压缩的客户端/服务器协议，可以减少通过网络传送的数据量。对大部分的MySQL 客户端程序，都可以使用--compress命令行选项来指定。

* 让MySQL插入默认值。也就是说，不在INSERT语句里指定各个列，让其随意分配为默认值。

* 对于MyISAM表，如果你需要将大量的数据加载到某个新表里，那么可以先创建不带索引的表，然后再创建索引。一次性创建全部的索引要比逐行修改它们更快一些。

    对于已带有索引的表，如果事先删除索引或关闭它，事后再重建索引或重新激活它，那么数据的加载速度可能会更快。
    * 如果要删除和重建索引，可以使用DROP INDEX和CREATE INDEX语句，或者使用ALTER TABLE语句与索引有关的形式。

    * 如果要关闭索引或重新激活它，那么可以使用ALTER TABLE的 DISABLE KEYS和ENABLE KEYS形式，它们可以分别打开和关闭表的非唯一性索引：

        ```mysql
        ALTER TABLE tbl_name DISABLE KEYS;
        ...多条用于加载表内容的语句...
        ALTER TABLE tbl_name ENABLE KEYS; 
        ```

    如果使用LOAD DATA语句来把数据加载到一个空白的MyISAM表里，那么服务器会自动 执行索引关闭和激活。另外，mysqldump默认也会添加ALTER TABLE语句。

* 对于lnnoDB表，删除和添加附表的速度很快，因此在加载大量数据之前可以考虑这样做。这种做法并不适用于主（集群）索引，因此请不要删除和添加那个索引。

前面所讨论的那些数据加载原则，也适用混合查询环境：其中涉及需要执行多种不同类型操作的多个客户端程序。

* 例如，你通常会希望尽量避免对那些经常会变化（即写入）的表， 长时间运行SELECT查询。因为那样做会造成多个写入者之间的竞争，会降低性能。

    如果大部分的写入动作都是INSERT操作，那么这个问题也许能这样解决：先把各个新行添加到一个辅助表里，然后再将这些行定期地添加到主表。

    如果你需要能够立即访问新行，那么就不能使用这种方法。但是，如果你能保证在较短时间内不去访问它们，那么使用辅助表会有两个好处。

    * 首先，可以减少发生在主表上的多条SELECT查询语句之间的竞争，让它们执行得更快。
    * 其次， 从辅助表里把行批量加载到主表，总体来讲，会比单独加载各行更省时，因为大批量加载操作的速度更快。

此策略的一种应用场景是：你想要把Web页面的访问记录从Web服务器写入MySQL数据库。此时，确定哪些条目需要立即进入主表，可能就不是一件需要优先考虑的事情。

## 5.6 调度、锁定和并发

本节介绍MySQL的调度策略，以及存储引擎锁定层在多个客户端之间的并发性方面所具有的常规影响。

当需要针对具体应用选择存储引擎时，可以参考一下本节的信息。为了方便讨论，把负责检索（操作语句为 SELECT）的客户端定义为读取者，把修改表（操作语句为DELETE、INSERT、REPLACE或UPDATE）的客户端定义为写入者。

MySQL的调度策略总结如下：

* 写入的优先级比读取的高。

* 表的写入操作一次只能进行一个，多个写入请求按其到达的先后顺序依次处理。 

* 可以同时处理多个对同一个表的读取操作。

lnnoDB存储引擎利用**行级的锁定操作**，实现这种调度策略，但lnnoDB**只有在必要时才会锁定行**。在许多情况下，如只读的操作完成之时，lnnoDB根本不使用锁定操作。

存储引擎MyISAM、MERGE和MEMORY，使用了**表锁定**。执行LOCK TABLES和UNLOCK TABLE 语句可以显式地获得和解除锁定。但在通常情况下，服务器的锁定管理器都可以在需要时自动获得锁定，而在不需要时，解除它们。所需的锁定类型取决于客户端执行的是写入操作，还是读取操作。

* 为把数据写入表，客户端必须具有对表进行互斥访问的锁定。

* 为从表里读取数据，客户端必须锁定它，以防止其他客户端把数据写入表，或者在读取数据期间修改它。但是，这个锁定操作不需要互斥访问。

存储引擎使用的锁定级别，对客户端之间的并发性有显著的影响。

**一般情况下，更精细的锁定会有更好的并发性**，因为如果各个客户端使用的是表的不同部分，那么可以让更多的客户端同时使用这个表。实际的影响是：不同的存储引擎适合不同的查询语句混合情况

* 当有许多更新操作时，InnoDB表可以提供更好的性能。因为完成锁定操作的级别是行级，而非表级，所以表被锁定的范围相对较小。这种做法可以减少锁定竞争，从而增强并发性。 
* MyISAM表的检索速度极快。但是，在有多个检索和更改操作混杂在一起的环境里，特别是当检索需要运行较长时间时，使用表级锁定可能会引发问题。在这些情况下，更新操作可能需要等待很长时间才能得到处理。 

**就死锁防止而言，表锁定能比更精细的锁定带来更多的好处**。

* 使用表锁定，不会出现死锁问题。服务器可以通过查看语句来确定需要哪些表，并**提前全部锁定**。

* 对于InnoDB表，可能会出现死锁问题，因为在事务开始的时候，该**存储引擎还没有获得所有必要的锁定**（在事务处理过程中，只有在必要时才需要获得锁定）

    有可能出现这种情况，两个查询都获得了锁定，然后它们会试图进一步获得这样的锁定：它们每一个都在期望那些已占用的锁定被解除。结果，每一个客户端都在它能继续下一步操作之前，占据着其他客户端所需要的锁定。这就会导致死锁，并且只有服务器中止其中一个事务才能解决此问题。